exit
@errors
next
@curr_token
exit
next
exit
next
exit
@peek_token
peek_token
conditionn
next
exit
condition
next
@peek_token
peek_token
token
continue
exit
next
stack
next
infix
next
left_expression
next
@curr_token
prefix
next
@curr_token
next
prefix
@curr_token
next
exit
next
@peek_token
next
left_expression
next
left
right
next
self
next
self
slef
next
@curr_token
continue
next
right
next
exit
@statements.map(&:to_s)
exit
@expression.to_s
@expression
self
exit
@statements.map(&:to_s)
continue
@statements.map(&:to_s)
exit
@statements.map { |s| pp s.to_s }
@statements.map { |s| pp s }
@statements.map(&:to_s)
@statements
continue
value.is_a?(Integer)
value
continue
value.is_a?(Integer)
value
continue
value
continue
value
continue
value
exit
value.is_a? String
value === String
value.class === String
value === String
value
next
value
continue
value
continue
value
exit
TrueClass === Integer.class
next
value.class
value
continue
value
continue
value
continue
value
continue
value
exit
@curr_token
@peek_token
next
@curr_token
@peek_token
next
@peek_token
@curr_token
next
@curr_token
@peek_token
next
@peek_token
@curr_token
next
@peek_token
@curr_token
exit
@curr_token.type
@curr_token
left_expression
next
infix
next
@curr_token
self
exit
@curr_token
next_token!
right
left
@curr_token
self
exit
self
continue
self
continue
self
continue
@input[@next_position]
self
@input[@next_position]
self
continue
self
continue
self
continue
self
exit
continue
self
exit
@input.size
exit
self
continue
self
continue
self
continue
self
continue
self
continue
self
continue
exit
self
exit
@input.size
input.size
eof?
self
exit
word
letter?
next
self
curr_char
next
curr_char
whitespace?
exit
next
lexer
exit
read_current_position
self
curr_char
next
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
read_current_position
self
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
cotinue
curr_char
exit
lexer
next
self
exit
let i = 1;
exit
next
whitespace?
curr_char
exit
curr_char
whitespace?
exit
read_current_position
skip_whitespace!
read_current_position
read_at_position
input
curr_char
exit
token
puts token
exit
lexer.next_token!
lexer
lexer.next_token!
token
exit
lexer.next_token!
lexer
continue
curr_char
eof?
