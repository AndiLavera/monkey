exit
read_current_position
self
curr_char
next
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
read_current_position
self
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
curr_char
continue
cotinue
curr_char
exit
lexer
next
self
exit
let i = 1;
exit
next
whitespace?
curr_char
exit
curr_char
whitespace?
exit
read_current_position
skip_whitespace!
read_current_position
read_at_position
input
curr_char
exit
token
puts token
exit
lexer.next_token!
lexer
lexer.next_token!
token
exit
lexer.next_token!
lexer
continue
curr_char
eof?
continue
next
curr_char
next
continue
word
next
curr_char
continue
curr_char
continue
curr_char
exit
continue
curr_char
continue
curr_char
exit
curr_char
continue
curr_char
exit
curr_char
word
continue
curr_char
exit
curr_char
token
continue
curr_char
continue
token
curr_char
continue
curr_char
next
curr_char
continue
curr_char
continue
exit
curr_char
continue
exit
curr_char
continue
curr_char
exit
input[read_position]
input.size
input
read_position
self
exit
curr_char
exit
i.size
puts i
i
next
h = 1
exit
i = 1
next
exit
helo info
i = "let helloWorld = 10;"
exit
i = "let helloWorld = 10;"
Lexer.new(input: 'let helloWorld = 10;').read_identifier
exit
input[read_position]
self.move_position
input[read_position]
self.move_position
input[read_position]
read_position >= input.size
input.size
read_position
